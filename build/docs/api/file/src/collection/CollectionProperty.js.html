<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/collection/CollectionProperty.js | F.lux API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/akrumel/f.lux" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Access.js~Access.html">Access</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ArrayProperty.js~ArrayProperty.html">ArrayProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ArrayShadow.js~ArrayShadow.html">ArrayShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AutoShader.js~AutoShader.html">AutoShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/IndexedApi.js~IndexedApi.html">IndexedApi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/IndexedProperty.js~IndexedProperty.html">IndexedProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/IndexedShadow.js~IndexedShadow.html">IndexedShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KeyedApi.js~KeyedApi.html">KeyedApi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MapProperty.js~MapProperty.html">MapProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MapShadow.js~MapShadow.html">MapShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ObjectProperty.js~ObjectProperty.html">ObjectProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrimitiveProperty.js~PrimitiveProperty.html">PrimitiveProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrimitiveShadowImpl.js~PrimitiveShadowImpl.html">PrimitiveShadowImpl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Property.js~Property.html">Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PropertyFactoryShader.js~PropertyFactoryShader.html">PropertyFactoryShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Shader.js~Shader.html">Shader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Shadow.js~Shadow.html">Shadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ShadowImpl.js~ShadowImpl.html">ShadowImpl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/StateType.js~StateType.html">StateType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Store.js~Store.html">Store</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TransientProperty.js~TransientLock.html">TransientLock</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TransientProperty.js~TransientProperty.html">TransientProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TransientProperty.js~TransientShadow.html">TransientShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Transients.js~TransientsProperty.html">TransientsProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Transients.js~TransientsShadow.html">TransientsShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createObject">createObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createPropertyClass">createPropertyClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-devDebug">devDebug</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extendProperty">extendProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isShadow">isShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modelize">modelize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-noParentStateErrorMsg">noParentStateErrorMsg</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-reshadow">reshadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-shadowProperty">shadowProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AllKey">AllKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CollectionAllKey">CollectionAllKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CollectionPojoEndpointPropertyKey">CollectionPojoEndpointPropertyKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CollectionPropertyKey">CollectionPropertyKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CollectionRestEndpointPropertyKey">CollectionRestEndpointPropertyKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ShadowImplKey">ShadowImplKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StoreKey">StoreKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TransientKey">TransientKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-error">error</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-info">info</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warn">warn</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">collection</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/CollectionProperty.js~CollectionProperty.html">CollectionProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/CollectionShadow.js~CollectionShadow.html">CollectionShadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/ModelAccess.js~ModelAccess.html">ModelAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/ModelProperty.js~ModelProperty.html">ModelProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/PojoEndpointProperty.js~PojoEndpointProperty.html">PojoEndpointProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/PojoQueryBuilder.js~PojoQueryBuilder.html">PojoQueryBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/RestEndpointProperty.js~RestEndpointProperty.html">RestEndpointProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/RestQueryBuilder.js~RestQueryBuilder.html">RestQueryBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/collection/ShadowModelAccess.js~ShadowModelAccess.html">ShadowModelAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extendOptions">extendOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getOptions">getOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setOptions">setOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULTS_OPTION">DEFAULTS_OPTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MERGE_OPTION">MERGE_OPTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NONE_OPTION">NONE_OPTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-REPLACE_OPTION">REPLACE_OPTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AllOp">AllOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ChangeEvent">ChangeEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CreateOp">CreateOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DeletedEvent">DeletedEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DestroyOp">DestroyOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ErrorEvent">ErrorEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FetchOp">FetchOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FetchedEvent">FetchedEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FindOp">FindOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FoundEvent">FoundEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SavedEvent">SavedEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UpdateOp">UpdateOp</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">decorators</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-automount">automount</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mixin">mixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-shadow">shadow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-shadowBound">shadowBound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-shadowPropertyHelper">shadowPropertyHelper</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">listeners</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/listeners/Logger.js~FrameAction.html">FrameAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/listeners/Logger.js~LogFrame.html">LogFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/listeners/Logger.js~Logger.html">Logger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createConsoleLogger">createConsoleLogger</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/collection/CollectionProperty.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {
	assert,
	isObject,
	uuid,
	doneIterator,
	iteratorFor,
	iterateOver,
} from &quot;akutils&quot;;

import Emitter from &quot;component-emitter&quot;;
import invariant from &quot;invariant&quot;;

import ArrayProperty from &quot;../ArrayProperty&quot;;
import createPropertyClass from &quot;../createPropertyClass&quot;;
import ObjectProperty from &quot;../ObjectProperty&quot;;
import MapProperty from &quot;../MapProperty&quot;;
import PrimitiveProperty from &quot;../PrimitiveProperty&quot;;
import Store from &quot;../Store&quot;;

import CollectionShadow from &quot;./CollectionShadow&quot;;
import ModelProperty from &quot;./ModelProperty&quot;;
import StateType from &quot;../StateType&quot;;

import appDebug, { CollectionPropertyKey as DebugKey } from &quot;../debug&quot;;
const debug = appDebug(DebugKey);


const _endpoint = &quot;_endpoint&quot;;
//const _fetching = &apos;_fetching&apos;;
const _id2cid = &quot;_id2cid&quot;;
const _idName = &quot;idName&quot;;
const _lastPageSize = &apos;lastPageSize&apos;;
const _limit = &apos;_limit&apos;;
const _models = &quot;_models&quot;;
const _nextOffset = &apos;nextOffset&apos;;
const _paging = &apos;_paging&apos;;
const _synced = &quot;synced&quot;;

const _autocheckpoint = Symbol(&quot;autocheckpoint&quot;);
const _fetching = Symbol(&apos;fetching&apos;);
const _middleware = Symbol(&quot;middleware&quot;);
const _offlineState = Symbol(&apos;offlineState&apos;);

/*
	Event emitted on collection changes.
*/
export const ChangeEvent = &quot;change&quot;;
/*
	Event emitted on collection destroy() success.
*/
export const DeletedEvent = &quot;deleted&quot;;
/*
	Event emitted on collection fetch() success.
*/
export const FetchedEvent = &quot;fetched&quot;;
/*
	Event emitted on collection find() success.
*/
export const FoundEvent = &quot;sound&quot;;
/*
	Event emitted on error during an operation.
*/
export const ErrorEvent = &quot;error&quot;;
/*
	Event emitted on collection save() success.
*/
export const SavedEvent = &quot;saved&quot;;

/*
	Middleware operation for create requests.
*/
export const CreateOp = &quot;create&quot;;
/*
	Middleware operation for destroy requests.
*/
export const DestroyOp = &quot;destroy&quot;;
/*
	Middleware operation for fetch requests.
*/
export const FetchOp = &quot;fetch&quot;;
/*
	Middleware operation for find requests.
*/
export const FindOp = &quot;find&quot;;
/*
	Middleware operation for update requests.
*/
export const UpdateOp = &quot;update&quot;;
/*
	All middleware operations.
*/
export const AllOp = [ CreateOp, DestroyOp, FetchOp, FindOp, UpdateOp ];

import { DEFAULTS_OPTION, MERGE_OPTION, NONE_OPTION, REPLACE_OPTION, REPLACE_ALL_OPTION } from &quot;./CollectionOptions&quot;;


/*
	Todo:
		* _id2cid and _models to ObjectProperty to remove overhead
*/
export default class CollectionProperty extends ObjectProperty {
	constructor(stateType) {
		super(stateType);

		this.setShadowClass(CollectionShadow);

		this[_middleware] = {
			[CreateOp]: [],
			[DestroyOp]: [],
			[FetchOp]: [],
			[FindOp]: [],
			[UpdateOp]: [],
		}

		// keep isFetching as an instance variable because transient data and gives immediate
		// feedback to prevent concurrent fetches
		this[_fetching] = false;
		this[_autocheckpoint] = false;

		this._keyed.addPropertyType(_idName, PrimitiveProperty.type.initialState(&quot;id&quot;).autoshadow);
		this._keyed.addProperty(_id2cid, new MapProperty());
		this._keyed.addPropertyType(_synced, PrimitiveProperty.type.initialState(false).autoshadowOff.readonly);

		// pagingTime instance variable used for ensuring overlapping paging requests do not mess up offset
		// this can happen when a paging request is in progress when limit is changed
		this.pagingTime = null;
		this._keyed.addPropertyType(_lastPageSize, PrimitiveProperty.type.initialState(null).autoshadowOff.readonly);
		this._keyed.addPropertyType(_limit, PrimitiveProperty.type.initialState(50).autoshadowOff.readonly);
		this._keyed.addPropertyType(_nextOffset, PrimitiveProperty.type.initialState(0).autoshadowOff.readonly);
		this._keyed.addPropertyType(_paging, PrimitiveProperty.type.initialState(false).autoshadowOff.readonly);

		// &apos;_models&apos; property contains ModelProperty objects which in turn keep their model state in
		// the &apos;data&apos; whose type is specified by the stateType.getManagedType() value (default is
		// MapProperty.type)
		const models = new MapProperty();
		const modelsShader = models.shader();

		this._keyed.addProperty(_models, models);
		modelsShader.setElementType(ModelProperty.type);

		// set the type for each retrieved model by explicitly adding a type to the models element shader
		const managedType = this.stateType().getManagedType() || MapProperty.type;
		modelsShader.elementShader().addProperty(&quot;data&quot;, managedType);
	}

	/*
		Factory function for creating an CollectionProperty subclass suitable for using with new.

		Parameters (all are optional):
			shadowType: one of a pojo or class. This parameter defines the new property
				shadow. If pojo specified, each property and function is mapped onto a CollectionShadow
				subclass.
			specCallback: a callback function that will be passed the StateType spec for additional
				customization, such as setting autoshadow, initial state, or readonly.
			initialState: the initial state for the new property. (default is {})
	*/
	static createClass(shadowType={}, specCallback, initialState={}) {
		return createPropertyClass(shadowType, initialState, specCallback, CollectionProperty, CollectionShadow);
	}

	/*
		Factory function for creating a StateType with an appropriately set intial state.

		Parameters:
			PropClass: CollectionProperty subclass (required)
			ShadowClass: Shadow subclass (optional)
			specCallback: a callback function that will be passed the StateType spec for additional
				customization, such as setting autoshadow or readonly. (optional)
			initialState: the initial state for the new property. (default is {})
	*/
	static defineType(PropClass, ShadowType, specCallback, initialState={}) {
		assert( a =&gt; a.is(CollectionProperty.isPrototypeOf(PropClass), &quot;PropClass must subclass CollectionProperty&quot;) );

		return StateType.defineTypeEx(PropClass, ShadowType, specCallback, initialState);
	}

	/*
		Override the base functionality method, and not designed life-cycle method propertyWillUpdate(), so
		subclasses can do the normal override without using super.propertyWillUpdate() to preserve functionality.
	*/
	onPropertyDidUpdate() {
		super.onPropertyDidUpdate();

		this.emit(ChangeEvent, this._(), this);
	}


	//------------------------------------------------------------------------------------------------------
	// Checkpoint support API
	//------------------------------------------------------------------------------------------------------
	isAutocheckpoint() {
		return this[_autocheckpoint];
	}

	setAutocheckpoint(auto) {
		this[_autocheckpoint] = auto;
	}

	//------------------------------------------------------------------------------------------------------
	// Offline data support API
	//------------------------------------------------------------------------------------------------------

	/*
		Experimental feature

		Gets an object capable of providing a persisted version of this collection. The object must
		expose a single method with the form:

			restore()
				Method sets the collection state for offline access.
	*/
	getOfflineState() {
		return this[_offlineState];
	}

	/*
		Experimental feature

		Sets an object capable of providing a persisted version of this collection. The object must
		expose a single method with the form:

			restore()
				Method sets the collection state for offline access.
	*/
	setOfflineState(offline) {
		this[_offlineState] = offline;
	}


	//------------------------------------------------------------------------------------------------------
	// Middleware API
	//------------------------------------------------------------------------------------------------------

	/*
		Registers collection middleware operation. A middleware operation is invoked before each asynchronous/
		network operation. Middleware operations are functions with the following format:
			fn(shadow, property)

		Middleware functions must return a promise and are invoked in the order registered. A function
		generating an error will terminate the middleware chain and the collection operation will not
		be performed.
	*/
	use(op, mw) {
		op = Array.isArray(op) ?op :[ op ];

		assert( a =&gt; { for (const o of op) a.has(this[_middleware], o) });

		for (const mwop of op) {
			this[_middleware][mwop].push(mw);
		}
	}

	/*
		Serially invokes each middleware function for the specified operation.
	*/
	_on(op, idx=0) {
		assert( a =&gt; a.is(this[_middleware][op], `Unknown middleware operation: ${op}`) );

		const mw = this[_middleware][op];
		const next = mw[idx];

		if (!next) {
			return Store.resolve(this._());
		}

		try {
			return next(this._(), this, op)
				.then( () =&gt; this._on(op, idx+1) );
		} catch(error) {
			return Store.reject(error);
		}
	}

	/*
		Experimental feature to update values with any modifications from the server.
	*/
	resync() {
		const values = this._().valuesArray();
		var currSync;
		var lastUpdate = null;
		var initialId = Number.MAX_SAFE_INTEGER;
		var filter, id, v, updatedAt;

		// Todo: break out filter parameters to a pluggable function
		// iterate all values and determine the greatest updated_at
		for (let i=0, len=values.length; i&lt;len; i++) {
			v = values[i];

			if (!v) { continue }

			id = v.id;
			updatedAt = v.updated_at;

			if (id &lt; initialId) {
				initialId = id;
			}

			if (!lastUpdate || lastUpdate &lt; updatedAt) {
				lastUpdate = updatedAt;
			}
		}

		// setup the refresh criteria
		if (lastUpdate) {
			filter = this.endpoint.queryBuilder();

			filter.gte(&quot;initial_id&quot;, initialId);
			filter.gt(&quot;updated_at&quot;, lastUpdate);
		}

		debug( d =&gt; d(`resync() - path=${ this.dotPath() }, initial_id=${initialId}, updated_at=${lastUpdate}`) );

// Todo: rework network call returns two arrays: new/modified models and deleted model IDs
//       as currently structured there is no delete support.
//       What about dirty models? Perhaps they should not be touched if there is a conflict.

		return this.fetch(filter, MERGE_OPTION, !lastUpdate);
	}

	//------------------------------------------------------------------------------------------------------
	// Paging API (could improve by adding two offsets and maintain max pages)
	//------------------------------------------------------------------------------------------------------

	fetchNext(mergeOp=MERGE_OPTION) {
		if (this.pagingTime) {
			throw new Error(&quot;Paging operation in progress&quot;);
		} else if (!this.hasMorePages()) {
			return Store.resolve(this._());
		}

		const filter = this.endpoint.queryBuilder();
		const time = this.pagingTime = Date.now();

		this._keyed.set(_paging, true);

		filter.equals(&quot;offset&quot;, this._()[_nextOffset]);
		filter.equals(&quot;limit&quot;, this._()[_limit]);

		return this.fetch(filter, mergeOp, false, (error, models) =&gt; {
				// bail if paging times do not match (offset likely reset)
				if (time !== this.pagingTime) { return }

				this.pagingTime = null;
				this._keyed.set(_paging, false);
				if (error) { return }

				this._keyed.set(_nextOffset, this._()[_nextOffset] + models.length);
				this._keyed.set(_lastPageSize, models.length);

				if (models.length &lt; this._()[_limit]) {
					this._keyed.set(_synced, true);
				}
			});
	}

	isPaging(state=this._()) {
		// use pagingTime instance variable (instant) and _paging state variable (tied to state) to
		// return the most conservative value
		return this.pagingTime || state[_paging];
	}

	hasMorePages(state=this._()) {
		return this.isConnected() &amp;&amp;
			!state[_synced] &amp;&amp;
			(!state[_lastPageSize] || this._()[_lastPageSize] &gt;= this._()[_limit]);
	}

	nextOffset() {
		return this._keyed.get(_nextOffset);
	}

	resetPaging() {
		this.pagingTime = null;
		this._keyed.set(_lastPageSize, null);
		this._keyed.set(_nextOffset, 0);
		this._keyed.set(_paging, false);
	}

	setLimit(limit) {
		this.pagingTime = null;

		this._keyed.set(_limit, limit);
		this._keyed.set(_lastPageSize, null);
		this._keyed.set(_nextOffset, 0);
		this._keyed.set(_paging, false);
	}


	//------------------------------------------------------------------------------------------------------
	// Endpoint methods
	//------------------------------------------------------------------------------------------------------

	get endpoint() {
		return this.isActive() &amp;&amp; this._()[_endpoint];
	}

	get endpointId() {
		const endpoint = this.endpoint;

		return endpoint &amp;&amp; endpoint.id;
	}

	clearEndpoint() {
		this.removeAllModels();
		this.removeProperty(_endpoint);
	}

	setEndpoint(endPoint) {
		this.setFetching(false);
		this.resetPaging();
		this.removeAllModels();
		this._keyed.addProperty(_endpoint, endPoint);
	}


	//------------------------------------------------------------------------------------------------------
	// Collection methods
	//------------------------------------------------------------------------------------------------------

	get modelsCount() {
		return this._()[_models].size;
	}

	/*
		Synchronously adds a new model object to the store. Call model.$().save() to persist the newly added
		object.

		Parmaeters:
			state - the object model to add to the collection
			merge - boolean declaring whether this state should be merged over an existing model with
				the same ID. False means a current model will be replaced with the new model value.

		Returns the object&apos;s ID. And ID is assigned if the &apos;id&apos; parameter was not set and it could not
			be found in the &apos;state&apos; parameter.
	*/
	addModel(state, mergeOp=REPLACE_OPTION) {
		if (!this.isConnected()) { throw new Error(`Collection is not connected.`) }

		const id = this.extractId(state);
		var modelId;

		// just add the model
		if (!id || !this.hasModel(id) || mergeOp === REPLACE_OPTION) {
			let modelDefn = ModelProperty.modelDefinitionFor(state, this);
			let models = this._()[_models];

			models.set(modelDefn.cid, modelDefn);

			modelId = modelDefn.id;
		} else {
			let currModel = this._getModel(id);

			switch (mergeOp) {
				case NONE_OPTION:
					break;
				case MERGE_OPTION:
					currModel.merge(state);
					break;
				case REPLACE_OPTION:
					currModel.setData(state);
					break;
				case DEFAULTS_OPTION:
					currModel.defaults(state);
					break;
				default:
					throw new Error(`Invalid post-save option: ${mergeOp}`)
			}

			modelId = currModel.id;
		}

		return modelId;
	}

	/*
		Bulk adds multiple models. Models must have an ID as it is assumed they have been previously
		saved.

		Parameters:
			models - array of model values
			merge - boolean declaring whether each state should be merged over an existing model with
				the same ID. False means a current model will be replaced with the new model value.
			syncOp - sets the synced flag to true if this parameter is true
	*/
	addModels(models, mergeOp=REPLACE_OPTION, syncOp=true) {
		if (!this.isConnected()) { throw new(`Collection ${this.slashPath()} is not connected`) }

		var id, state;

		if (syncOp) {
			this._keyed.set(_synced, true);
		}

		for (let i=0, len=models.length; i&lt;len; i++) {
			this.addModel(models[i], mergeOp);
		}
	}

	/*
		Combines an add and save actions.
	*/
	create(model) {
		if (!this.isConnected()) { return Store.reject(`Collection ${this.slashPath()} is not connected`) }

		const cid = this.addModel(model);

		return this.store().waitThen()
			.then( () =&gt; this.save(cid) );
	}

	destroy(id) {
		if (!this.hasModel(id)) {
			return Store.resolve(this._());
		}

		try {
			const model = this._getModel(id);
			const epId = this.endpointId;

			if (!model) {
				return Store.resolve(id);
			} else if (model.isNew()) {
				this._()[_models].delete(model.cid);
				this._()[_id2cid].delete(model.id);

				return Store.resolve(id);
			}

			return this._on(DestroyOp)
				.then( () =&gt; {
						model.waiting = true;

						return this.endpoint.doDelete(model.id)
					})
				.then( () =&gt; {
						// ensure endpoint did not change
						if (epId !== this.endpointId) { return id }

						this._()[_models].delete(model.cid);
						this._()[_id2cid].delete(model.id);

						this.store().waitFor( () =&gt; this.emit(DeletedEvent, this._(), this) )

						return id;
					})
				.catch( error =&gt; {
						const currModel = model.$().latest();

						if (currModel) {
							currModel.waiting = false
						}

						return this.onError(error, `Destroy model: ${id}`)
					});
		} catch(error) {
			return this.onError(error, `Destroy model: ${id}`);
		}
	}

	fetch(filter=null, mergeOp=REPLACE_OPTION, replaceAll=true, callback) {
		if (!this.isConnected()) { return Store.reject(`Collection ${this.slashPath()} is not connected`) }

		const syncOp = !filter;
		const epId = this.endpointId;

		if (replaceAll) {
			this.setFetching(true);
		}

		try {
			return this._on(FetchOp)
				.then( () =&gt; {
						// ensure endpoint did not change
						if (epId !== this.endpointId) { return null }

						return this.endpoint.doFetch(filter);
					})
				.then( models =&gt; {
						try {
							// bail on fetch if endpoint changed
							if (epId !== this.endpointId) {
								return models;
							}

							if (replaceAll) {
								this.setFetching(false);
							}

							// invoke the callback before processing models
							callback &amp;&amp; callback(null, models);

							if (replaceAll) {
								this.setModels(models, syncOp);
							} else {
								this.addModels(models, mergeOp, syncOp);
							}

							return models;
						} catch(error) {
							return this.onError(error, &quot;Fetch error while setting models&quot;);
						}
					})
				.then( models =&gt; {
						// fire event if endpoint same
						if (epId === this.endpointId) {
							this.store().waitFor( () =&gt; this.emit(FetchedEvent, this._(), this) );
						}

						return models;
					})
				.catch( error =&gt; {
						// change fetching flag only if same endpoint
						if (replaceAll &amp;&amp; epId === this.endpointId) {
							this.setFetching(false);
						}

						// invoke the callback with the error
						callback &amp;&amp; callback(error, null);

						return this.onError(error, `Fetch all models`);
					});
		} catch(error) {
			if (replaceAll) {
				this.setFetching(false);
			}

			// invoke the callback with the error
			callback &amp;&amp; callback(error, null);

			debug( d =&gt; d(`fetch() top level error: ${error.stack || error}`) );

			throw Store.reject(error);
		}
	}

	find(id) {
		if (!this.isConnected()) { return Store.reject(`Collection ${this.slashPath()} is not connected`) }

		try {
			const model = this._getModel(id);
			const epId = this.endpointId;

			if (model) {
				return Store.resolve(model.data);
			} else {
				return this._on(FindOp)
					.then( () =&gt; {
							// ensure endpoint did not change
							if (epId !== this.endpointId) { return null }

							return this.endpoint.doFind(id) ;
						})
					.then( state =&gt; {
							// ensure endpoint did not change
							if (epId !== this.endpointId) { return null }

							this.addModel(state, NONE_OPTION);
							this.store().waitFor( () =&gt; this.emit(FoundEvent, this._(), this) );

							return this.getModel(id);
						})
					.catch( error =&gt; this.onError(error, `Find model ${id}`) );
			}
		} catch(error) {
			return this.onError(error, `Find model ${id}`);
		}
	}

	getModel(id, state=this._()) {
		const model = this._getModel(id, state);

		return model &amp;&amp; model.data;
	}

	hasModel(id, state=this._()) {
		return state[_id2cid].has(id) || state[_models].has(id);
	}

	/*
		Gets if the collection is active (has a shadow) and an endpoint.
	*/
	isConnected() {
		return this._() &amp;&amp; this._()[_endpoint] &amp;&amp; this._()[_endpoint].isConnected();
	}

	isFetching() {
		return this[_fetching];
	}

	isNew(id, state=this._()) {
		const model = this._getModel(id, state);

		return !model || model.isNew();
	}

	isNewModel(shadow) {
		const id = this.extractId(shadow);

		return !id;
	}

	/*
		Gets the shadow models currently managed by the collection.

		Returns an array of models already fetched and/or added.
	*/
	modelsArray(state) {
		if (!state &amp;&amp; !this.isConnected()) { throw new Error(`Collection is not connected.`) }

		state = state || this._();

		const models = state[_models];
		const keys = Object.keys(models);
		const result = [];

		for (let i=0, len=keys.length; i&lt;len; i++) {
			result.push( models[keys[i]].data );
		}

		return result;
	}

	modelEntries(state) {
		if (!state &amp;&amp; !this.isActive()) { return doneIterator; }

		state = state || this._();

		const models = state[_models];
		const keys = this.modelKeysArray(state);

		return iterateOver(keys, key =&gt; [key, this.getModel(key)] );
	}

	modelKeys(state=this._()) {
		// too brute force but quick and sure to work
		return iteratorFor(this.modelKeysArray(state));
	}

	modelKeysArray(state) {
		if (!state &amp;&amp; !this.isActive()) { return []; }

		state = state || this._();

		return Object.keys(state[_models]);
	}

	modelValues(state=this._()) {
		return iterateOver(this.modelKeysArray(state), key =&gt; this.getModel(key, state));
	}

	/*
		Synchronously removes the model from the collection without performing an endpoint operation.
	*/
	remove(id) {
		if (!this.hasModel(id)) { return }

		const model = this._getModel(id);
		const prevShadow = this._();

		this._()[_models].delete(model.cid);
		this._()[_id2cid].delete(model.id);
	}

	/*
		Removes all models from the collection and marks the collection as having not synched with the
		endpoint.
	*/
	removeAllModels() {
		if (!this.isActive()) { return }

		this._keyed.set(_synced, false);
		this._()[_models].clear();
		this._()[_id2cid].clear();
	}

	/*
		Saves a model through the endpoint.

		Parameters:
			id - the model id or cid
			mergeOp - one of constants: DEFAULTS, MERGE, NONE, REPLACE

		Returns a promise. The resolve function arguments are F.lux models and this adapter as arguments
	*/
	save(id, mergeOp=MERGE_OPTION) {
		if (!this.isConnected()) { return Store.reject(`Collection ${this.slashPath()} is not connected`) }

		const model = this._getModel(id);
		const cid = model &amp;&amp; model.cid;
		const shadow = model &amp;&amp; model.data;

		if (!model) { return Store.reject(`Collection ${this.slashPath()} model not found: id=${id}`) }

		try {
			const shadowState = shadow.__().nextState();
			const opName = this.isNewModel(shadow) ?CreateOp :UpdateOp;
			const epId = this.endpointId;

			return this._on(opName)
				.then( () =&gt; {
						// ensure endpoint did not change
						if (epId !== this.endpointId) { return null }

						model.waiting = true;

						if (this.isNewModel(shadow)) {
							return this.endpoint.doCreate(shadow, shadowState);
						} else {
							return this.endpoint.doUpdate(model.id, shadow, shadowState);
						}
					})
				.then( savedState =&gt; {
						// ensure endpoint did not change
						if (epId !== this.endpointId) { return model }

						const currModel = model.$().latest();
						const savedId = this.extractId(savedState);

						currModel.waiting = false;

						// Put an entry in id-&gt;cid mapping
						if (savedId != id) {
							this._()[_id2cid].set(savedId, cid);
						}

						switch (mergeOp) {
							case NONE_OPTION:
								if (savedId !== id) {
									currModel.changeId(savedId);
								}

								break;
							case MERGE_OPTION:
								currModel.merge(savedState);
								break;
							case REPLACE_OPTION:
								currModel.setData(savedState);
								break;
							case DEFAULTS_OPTION:
								currModel.defaults(savedState);
								break;
							default:
								return Store.reject(`Invalid post-save option: ${mergeOp}`);
						}

						currModel.$$().clearDirty();

						return this.store()
								.waitThen()
								.then( () =&gt; currModel.$().latest() );
					})
				.then( model =&gt; {
						// ensure endpoint did not change
						if (epId === this.endpointId) {
							this.store().setTimeout( () =&gt; this.emit(SavedEvent, this._(), this) );
						}

						return model &amp;&amp; model.data;
					})
				.catch( error =&gt; {
						let currModel = model.$().latest();

						if (currModel) {
							currModel.waiting = false
						}

						return this.onError(error, `Save ${id} - cid=${currModel.cid}`)
					});
		} catch(error) {
			return this.onError(error, `Save ${id} - cid=${model.cid}`);
		}
	}

	setIdName(idName) {
		this._()[_idName] = idName;
	}

	setFetching(fetching) {
		this[_fetching] = fetching;
		this.touch();
//		this._keyed.set(_fetching, fetching);
	}

	/*
		Bulk replaces current models with an array of new models.

		See comments for addModels().
	*/
	setModels(models, syncOp=true) {
		this.removeAllModels();
		this.addModels(models, REPLACE_OPTION, syncOp);
	}


	//------------------------------------------------------------------------------------------------------
	// Methods Collection subclasses may want to override
	//------------------------------------------------------------------------------------------------------

	/*
		Generates an ID for a new object. The default implementation generates: temp-[UUID].
	*/
	makeId() {
		return `temp_${ uuid(&apos;_&apos;) }`;
	}

	/*
		Subclasses can override this method to remove underlying transport specific properties.
	*/
	clean(json) {
		return json;
	}

	/*
		Used by the private _shadow() method to get the id from the model JSON representation as returned by the
		subclass doXXX() apis. The default implementation simply returns the &apos;id&apos; model property.
	*/
	extractId(model) {
		var idName = this._()[_idName];

		return isObject(model) ?model[idName] :model;
	}

	onError(error, opMsg) {
		var msg;

		if (error.status) {
			let statusText = error.status
				?error.response.statusText || `HTTP Code=${error.status}`
				:&quot;HTTP status code not specified&quot;
			msg = `Error during collection operation &apos;${opMsg} (${ this.endpointId })&apos; - ` +
			      `Server Error: status=${statusText}`;
		} else if (error.message) {
			msg = `Error during collection operation &apos;${opMsg} (${ this.endpointId })&apos; - Collection Error: ${error.message}`;
		} else {
			msg = `Error during collection operation &apos;${opMsg} (${ this.endpointId })&apos; - Error: ${error}`;
		}

		debug( d =&gt; d(`Error: ${msg}`, error) );

		const collectionError = new Error(msg);

		collectionError.status = error.status;
		collectionError.endpointError = error;

		this.emit(ErrorEvent, collectionError, this._(), this);

		return Store.reject(collectionError);
	}

	//------------------------------------------------------------------------------------------------------
	// Private methods
	//------------------------------------------------------------------------------------------------------

	/*
		Gets the Model container object NOT the actual model.
	*/
	_getModel(id, state=this._()) {
		const id2cid = state[_id2cid];
		var cid = id2cid.has(id) ?id2cid.get(id) :id;

		return state[_models].get(cid);
	}
}


StateType.defineType(CollectionProperty, spec =&gt; {
	spec.initialState({})
		.autoshadowOff
		.managedType(MapProperty.type)
		.typeName(&quot;CollectionProperty&quot;);
});

// Mix in `Emitter`
Emitter(CollectionProperty.prototype);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
